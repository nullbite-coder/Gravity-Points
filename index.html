<!DOCTYPE html>
<!-- saved from url=(0012)about:srcdoc -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

  
  
<link rel="apple-touch-icon" type="image/png" href="logo.png">
<meta name="apple-mobile-web-app-title" content="HOWTOKR">

<link rel="shortcut icon" type="image/x-icon" href="logo.png">

<link rel="mask-icon" type="" href="logo.png" color="#111">


  <title>HOW TO KR - Gravity Points</title>
  
  
  
  
  
<style>
body {
    font-family: Helvetica sans-serif;
    padding: 0;
    margin: 0;
    background-color: #222;
    overflow: hidden;
    -webkit-user-select: none;
       -moz-user-select: none;
         -o-user-select: none;
        -ms-user-select: none;
            user-select: none;
}

canvas {
    position: absolute;
    top: 0;
    left: 0;
}

.info {
    position: absolute;
    top: 0;
    left: 0;
    padding: 5px 15px;
    color: #eee;
    font-size: 13px;
    background-color: rgba(0, 0, 0, .5);
}
.header {
  padding: 5px;
  text-align: center;
  background: #000000;
  color: white;
  font-size: 10px;
}
</style>

  <script>
  window.console = window.console || function(t) {};
</script>

  
  
  <script>
  if (document.location.search.match(/type=embed/gi)) {
    window.parent.postMessage("resize", "*");
  }
</script>


<style type="text/css">.dg {
  /** Clear list styles */
  /* Auto-place container */
  /* Auto-placed GUI's */
  /* Line items that don't contain folders. */
  /** Folder names */
  /** Hides closed items */
  /** Controller row */
  /** Name-half (left) */
  /** Controller-half (right) */
  /** Controller placement */
  /** Shorter number boxes when slider is present. */
  /** Ensure the entire boolean and function row shows a hand */ }
  .dg ul {
    list-style: none;
    margin: 0;
    padding: 0;
    width: 100%;
    clear: both; }
  .dg.ac {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    height: 0;
    z-index: 0; }
  .dg:not(.ac) .main {
    /** Exclude mains in ac so that we don't hide close button */
    overflow: hidden; }
  .dg.main {
    -webkit-transition: opacity 0.1s linear;
    -o-transition: opacity 0.1s linear;
    -moz-transition: opacity 0.1s linear;
    transition: opacity 0.1s linear; }
    .dg.main.taller-than-window {
      overflow-y: auto; }
      .dg.main.taller-than-window .close-button {
        opacity: 1;
        /* TODO, these are style notes */
        margin-top: -1px;
        border-top: 1px solid #2c2c2c; }
    .dg.main ul.closed .close-button {
      opacity: 1 !important; }
    .dg.main:hover .close-button,
    .dg.main .close-button.drag {
      opacity: 1; }
    .dg.main .close-button {
      /*opacity: 0;*/
      -webkit-transition: opacity 0.1s linear;
      -o-transition: opacity 0.1s linear;
      -moz-transition: opacity 0.1s linear;
      transition: opacity 0.1s linear;
      border: 0;
      position: absolute;
      line-height: 19px;
      height: 20px;
      /* TODO, these are style notes */
      cursor: pointer;
      text-align: center;
      background-color: #000; }
      .dg.main .close-button:hover {
        background-color: #111; }
  .dg.a {
    float: right;
    margin-right: 15px;
    overflow-x: hidden; }
    .dg.a.has-save > ul {
      margin-top: 27px; }
      .dg.a.has-save > ul.closed {
        margin-top: 0; }
    .dg.a .save-row {
      position: fixed;
      top: 0;
      z-index: 1002; }
  .dg li {
    -webkit-transition: height 0.1s ease-out;
    -o-transition: height 0.1s ease-out;
    -moz-transition: height 0.1s ease-out;
    transition: height 0.1s ease-out; }
  .dg li:not(.folder) {
    cursor: auto;
    height: 27px;
    line-height: 27px;
    overflow: hidden;
    padding: 0 4px 0 5px; }
  .dg li.folder {
    padding: 0;
    border-left: 4px solid rgba(0, 0, 0, 0); }
  .dg li.title {
    cursor: pointer;
    margin-left: -4px; }
  .dg .closed li:not(.title),
  .dg .closed ul li,
  .dg .closed ul li > * {
    height: 0;
    overflow: hidden;
    border: 0; }
  .dg .cr {
    clear: both;
    padding-left: 3px;
    height: 27px; }
  .dg .property-name {
    cursor: default;
    float: left;
    clear: left;
    width: 40%;
    overflow: hidden;
    text-overflow: ellipsis; }
  .dg .c {
    float: left;
    width: 60%; }
  .dg .c input[type=text] {
    border: 0;
    margin-top: 4px;
    padding: 3px;
    width: 100%;
    float: right; }
  .dg .has-slider input[type=text] {
    width: 30%;
    /*display: none;*/
    margin-left: 0; }
  .dg .slider {
    float: left;
    width: 66%;
    margin-left: -5px;
    margin-right: 0;
    height: 19px;
    margin-top: 4px; }
  .dg .slider-fg {
    height: 100%; }
  .dg .c input[type=checkbox] {
    margin-top: 9px; }
  .dg .c select {
    margin-top: 5px; }
  .dg .cr.function,
  .dg .cr.function .property-name,
  .dg .cr.function *,
  .dg .cr.boolean,
  .dg .cr.boolean * {
    cursor: pointer; }
  .dg .selector {
    display: none;
    position: absolute;
    margin-left: -9px;
    margin-top: 23px;
    z-index: 10; }
  .dg .c:hover .selector,
  .dg .selector.drag {
    display: block; }
  .dg li.save-row {
    padding: 0; }
    .dg li.save-row .button {
      display: inline-block;
      padding: 0px 6px; }
  .dg.dialogue {
    background-color: #222;
    width: 460px;
    padding: 15px;
    font-size: 13px;
    line-height: 15px; }

/* TODO Separate style and structure */
#dg-new-constructor {
  padding: 10px;
  color: #222;
  font-family: Monaco, monospace;
  font-size: 10px;
  border: 0;
  resize: none;
  box-shadow: inset 1px 1px 1px #888;
  word-wrap: break-word;
  margin: 12px 0;
  display: block;
  width: 440px;
  overflow-y: scroll;
  height: 100px;
  position: relative; }

#dg-local-explain {
  display: none;
  font-size: 11px;
  line-height: 17px;
  border-radius: 3px;
  background-color: #333;
  padding: 8px;
  margin-top: 10px; }
  #dg-local-explain code {
    font-size: 10px; }

#dat-gui-save-locally {
  display: none; }

/** Main type */
.dg {
  color: #eee;
  font: 11px 'Lucida Grande', sans-serif;
  text-shadow: 0 -1px 0 #111;
  /** Auto place */
  /* Controller row, <li> */
  /** Controllers */ }
  .dg.main {
    /** Scrollbar */ }
    .dg.main::-webkit-scrollbar {
      width: 5px;
      background: #1a1a1a; }
    .dg.main::-webkit-scrollbar-corner {
      height: 0;
      display: none; }
    .dg.main::-webkit-scrollbar-thumb {
      border-radius: 5px;
      background: #676767; }
  .dg li:not(.folder) {
    background: #1a1a1a;
    border-bottom: 1px solid #2c2c2c; }
  .dg li.save-row {
    line-height: 25px;
    background: #dad5cb;
    border: 0; }
    .dg li.save-row select {
      margin-left: 5px;
      width: 108px; }
    .dg li.save-row .button {
      margin-left: 5px;
      margin-top: 1px;
      border-radius: 2px;
      font-size: 9px;
      line-height: 7px;
      padding: 4px 4px 5px 4px;
      background: #c5bdad;
      color: #fff;
      text-shadow: 0 1px 0 #b0a58f;
      box-shadow: 0 -1px 0 #b0a58f;
      cursor: pointer; }
      .dg li.save-row .button.gears {
        background: #c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;
        height: 7px;
        width: 8px; }
      .dg li.save-row .button:hover {
        background-color: #bab19e;
        box-shadow: 0 -1px 0 #b0a58f; }
  .dg li.folder {
    border-bottom: 0; }
  .dg li.title {
    padding-left: 16px;
    background: black url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;
    cursor: pointer;
    border-bottom: 1px solid rgba(255, 255, 255, 0.2); }
  .dg .closed li.title {
    background-image: url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==); }
  .dg .cr.boolean {
    border-left: 3px solid #806787; }
  .dg .cr.function {
    border-left: 3px solid #e61d5f; }
  .dg .cr.number {
    border-left: 3px solid #2fa1d6; }
    .dg .cr.number input[type=text] {
      color: #2fa1d6; }
  .dg .cr.string {
    border-left: 3px solid #1ed36f; }
    .dg .cr.string input[type=text] {
      color: #1ed36f; }
  .dg .cr.function:hover, .dg .cr.boolean:hover {
    background: #111; }
  .dg .c input[type=text] {
    background: #303030;
    outline: none; }
    .dg .c input[type=text]:hover {
      background: #3c3c3c; }
    .dg .c input[type=text]:focus {
      background: #494949;
      color: #fff; }
  .dg .c .slider {
    background: #303030;
    cursor: ew-resize; }
  .dg .c .slider-fg {
    background: #2fa1d6; }
  .dg .c .slider:hover {
    background: #3c3c3c; }
    .dg .c .slider:hover .slider-fg {
      background: #44abda; }
</style></head>

<body translate="no">
  <canvas id="c" width="1471" height="579" style="cursor: default;"></canvas>
    <script src="stopout.js"></script>

  <script src="new.js"></script>
  
      <script id="rendered-js">
/**
 * requestAnimationFrame
 */
window.requestAnimationFrame = function () {
  return window.requestAnimationFrame ||
  window.webkitRequestAnimationFrame ||
  window.mozRequestAnimationFrame ||
  window.oRequestAnimationFrame ||
  window.msRequestAnimationFrame ||
  function (callback) {
    window.setTimeout(callback, 1000 / 60);
  };
}();


/**
      * Vector
      */
function Vector(x, y) {
  this.x = x || 0;
  this.y = y || 0;
}

Vector.add = function (a, b) {
  return new Vector(a.x + b.x, a.y + b.y);
};

Vector.sub = function (a, b) {
  return new Vector(a.x - b.x, a.y - b.y);
};

Vector.scale = function (v, s) {
  return v.clone().scale(s);
};

Vector.random = function () {
  return new Vector(
  Math.random() * 2 - 1,
  Math.random() * 2 - 1);

};

Vector.prototype = {
  set: function (x, y) {
    if (typeof x === 'object') {
      y = x.y;
      x = x.x;
    }
    this.x = x || 0;
    this.y = y || 0;
    return this;
  },

  add: function (v) {
    this.x += v.x;
    this.y += v.y;
    return this;
  },

  sub: function (v) {
    this.x -= v.x;
    this.y -= v.y;
    return this;
  },

  scale: function (s) {
    this.x *= s;
    this.y *= s;
    return this;
  },

  length: function () {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  },

  lengthSq: function () {
    return this.x * this.x + this.y * this.y;
  },

  normalize: function () {
    var m = Math.sqrt(this.x * this.x + this.y * this.y);
    if (m) {
      this.x /= m;
      this.y /= m;
    }
    return this;
  },

  angle: function () {
    return Math.atan2(this.y, this.x);
  },

  angleTo: function (v) {
    var dx = v.x - this.x,
    dy = v.y - this.y;
    return Math.atan2(dy, dx);
  },

  distanceTo: function (v) {
    var dx = v.x - this.x,
    dy = v.y - this.y;
    return Math.sqrt(dx * dx + dy * dy);
  },

  distanceToSq: function (v) {
    var dx = v.x - this.x,
    dy = v.y - this.y;
    return dx * dx + dy * dy;
  },

  lerp: function (v, t) {
    this.x += (v.x - this.x) * t;
    this.y += (v.y - this.y) * t;
    return this;
  },

  clone: function () {
    return new Vector(this.x, this.y);
  },

  toString: function () {
    return '(x:' + this.x + ', y:' + this.y + ')';
  } };



/**
        * GravityPoint
        */
function GravityPoint(x, y, radius, targets) {
  Vector.call(this, x, y);
  this.radius = radius;
  this.currentRadius = radius * 0.5;

  this._targets = {
    particles: targets.particles || [],
    gravities: targets.gravities || [] };

  this._speed = new Vector();
}

GravityPoint.RADIUS_LIMIT = 65;
GravityPoint.interferenceToPoint = true;

GravityPoint.prototype = function (o) {
  var s = new Vector(0, 0),p;
  for (p in o) s[p] = o[p];
  return s;
}({
  gravity: 0.05,
  isMouseOver: false,
  dragging: false,
  destroyed: false,
  _easeRadius: 0,
  _dragDistance: null,
  _collapsing: false,

  hitTest: function (p) {
    return this.distanceTo(p) < this.radius;
  },

  startDrag: function (dragStartPoint) {
    this._dragDistance = Vector.sub(dragStartPoint, this);
    this.dragging = true;
  },

  drag: function (dragToPoint) {
    this.x = dragToPoint.x - this._dragDistance.x;
    this.y = dragToPoint.y - this._dragDistance.y;
  },

  endDrag: function () {
    this._dragDistance = null;
    this.dragging = false;
  },

  addSpeed: function (d) {
    this._speed = this._speed.add(d);
  },

  collapse: function (e) {
    this.currentRadius *= 1.75;
    this._collapsing = true;
  },

  render: function (ctx) {
    if (this.destroyed) return;

    var particles = this._targets.particles,
    i,len;

    for (i = 0, len = particles.length; i < len; i++) {
      particles[i].addSpeed(Vector.sub(this, particles[i]).normalize().scale(this.gravity));
    }

    this._easeRadius = (this._easeRadius + (this.radius - this.currentRadius) * 0.07) * 0.95;
    this.currentRadius += this._easeRadius;
    if (this.currentRadius < 0) this.currentRadius = 0;

    if (this._collapsing) {
      this.radius *= 0.75;
      if (this.currentRadius < 1) this.destroyed = true;
      this._draw(ctx);
      return;
    }

    var gravities = this._targets.gravities,
    g,absorp,
    area = this.radius * this.radius * Math.PI,garea;

    for (i = 0, len = gravities.length; i < len; i++) {
      g = gravities[i];

      if (g === this || g.destroyed) continue;

      if (
      (this.currentRadius >= g.radius || this.dragging) &&
      this.distanceTo(g) < (this.currentRadius + g.radius) * 0.85)
      {
        g.destroyed = true;
        this.gravity += g.gravity;

        absorp = Vector.sub(g, this).scale(g.radius / this.radius * 0.5);
        this.addSpeed(absorp);

        garea = g.radius * g.radius * Math.PI;
        this.currentRadius = Math.sqrt((area + garea * 3) / Math.PI);
        this.radius = Math.sqrt((area + garea) / Math.PI);
      }

      g.addSpeed(Vector.sub(this, g).normalize().scale(this.gravity));
    }

    if (GravityPoint.interferenceToPoint && !this.dragging)
    this.add(this._speed);

    this._speed = new Vector();

    if (this.currentRadius > GravityPoint.RADIUS_LIMIT) this.collapse();

    this._draw(ctx);
  },

  _draw: function (ctx) {
    var grd, r;

    ctx.save();

    grd = ctx.createRadialGradient(this.x, this.y, this.radius, this.x, this.y, this.radius * 5);
    grd.addColorStop(0, 'rgba(0, 0, 0, 0.1)');
    grd.addColorStop(1, 'rgba(0, 0, 0, 0)');
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius * 5, 0, Math.PI * 2, false);
    ctx.fillStyle = grd;
    ctx.fill();

    r = Math.random() * this.currentRadius * 0.7 + this.currentRadius * 0.3;
    grd = ctx.createRadialGradient(this.x, this.y, r, this.x, this.y, this.currentRadius);
    grd.addColorStop(0, 'rgba(0, 0, 0, 1)');
    grd.addColorStop(1, Math.random() < 0.2 ? 'rgba(255, 196, 0, 0.15)' : 'rgba(103, 181, 191, 0.75)');
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.currentRadius, 0, Math.PI * 2, false);
    ctx.fillStyle = grd;
    ctx.fill();
    ctx.restore();
  } });



/**
         * Particle
         */
function Particle(x, y, radius) {
  Vector.call(this, x, y);
  this.radius = radius;

  this._latest = new Vector();
  this._speed = new Vector();
}

Particle.prototype = function (o) {
  var s = new Vector(0, 0),p;
  for (p in o) s[p] = o[p];
  return s;
}({
  addSpeed: function (d) {
    this._speed.add(d);
  },

  update: function () {
    if (this._speed.length() > 12) this._speed.normalize().scale(12);

    this._latest.set(this);
    this.add(this._speed);
  }

  // render: function(ctx) {
  //     if (this._speed.length() > 12) this._speed.normalize().scale(12);

  //     this._latest.set(this);
  //     this.add(this._speed);

  //     ctx.save();
  //     ctx.fillStyle = ctx.strokeStyle = '#fff';
  //     ctx.lineCap = ctx.lineJoin = 'round';
  //     ctx.lineWidth = this.radius * 2;
  //     ctx.beginPath();
  //     ctx.moveTo(this.x, this.y);
  //     ctx.lineTo(this._latest.x, this._latest.y);
  //     ctx.stroke();
  //     ctx.beginPath();
  //     ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
  //     ctx.fill();
  //     ctx.restore();
  // }
});



// Initialize

(function () {

  // Configs

  var BACKGROUND_COLOR = 'rgba(11, 51, 56, 1)',
  PARTICLE_RADIUS = 1,
  G_POINT_RADIUS = 10,
  G_POINT_RADIUS_LIMITS = 65;


  // Vars

  var canvas,context,
  bufferCvs,bufferCtx,
  screenWidth,screenHeight,
  mouse = new Vector(),
  gravities = [],
  particles = [],
  grad,
  gui,control;


  // Event Listeners

  function resize(e) {
    screenWidth = canvas.width = window.innerWidth;
    screenHeight = canvas.height = window.innerHeight;
    bufferCvs.width = screenWidth;
    bufferCvs.height = screenHeight;
    context = canvas.getContext('2d');
    bufferCtx = bufferCvs.getContext('2d');

    var cx = canvas.width * 0.5,
    cy = canvas.height * 0.5;

    grad = context.createRadialGradient(cx, cy, 0, cx, cy, Math.sqrt(cx * cx + cy * cy));
    grad.addColorStop(0, 'rgba(0, 0, 0, 0)');
    grad.addColorStop(1, 'rgba(0, 0, 0, 0.35)');
  }

  function mouseMove(e) {
    mouse.set(e.clientX, e.clientY);

    var i,g,hit = false;
    for (i = gravities.length - 1; i >= 0; i--) {
      g = gravities[i];
      if (!hit && g.hitTest(mouse) || g.dragging)
      g.isMouseOver = hit = true;else

      g.isMouseOver = false;
    }

    canvas.style.cursor = hit ? 'pointer' : 'default';
  }

  function mouseDown(e) {
    for (var i = gravities.length - 1; i >= 0; i--) {
      if (gravities[i].isMouseOver) {
        gravities[i].startDrag(mouse);
        return;
      }
    }
    gravities.push(new GravityPoint(e.clientX, e.clientY, G_POINT_RADIUS, {
      particles: particles,
      gravities: gravities }));

  }

  function mouseUp(e) {
    for (var i = 0, len = gravities.length; i < len; i++) {
      if (gravities[i].dragging) {
        gravities[i].endDrag();
        break;
      }
    }
  }

  function doubleClick(e) {
    for (var i = gravities.length - 1; i >= 0; i--) {
      if (gravities[i].isMouseOver) {
        gravities[i].collapse();
        break;
      }
    }
  }


  // Functions

  function addParticle(num) {
    var i, p;
    for (i = 0; i < num; i++) {
      p = new Particle(
      Math.floor(Math.random() * screenWidth - PARTICLE_RADIUS * 2) + 1 + PARTICLE_RADIUS,
      Math.floor(Math.random() * screenHeight - PARTICLE_RADIUS * 2) + 1 + PARTICLE_RADIUS,
      PARTICLE_RADIUS);

      p.addSpeed(Vector.random());
      particles.push(p);
    }
  }

  function removeParticle(num) {
    if (particles.length < num) num = particles.length;
    for (var i = 0; i < num; i++) {
      particles.pop();
    }
  }


  // GUI Control

  control = {
    particleNum: 100 };



  // Init

  canvas = document.getElementById('c');
  bufferCvs = document.createElement('canvas');

  window.addEventListener('resize', resize, false);
  resize(null);

  addParticle(control.particleNum);

  canvas.addEventListener('mousemove', mouseMove, false);
  canvas.addEventListener('mousedown', mouseDown, false);
  canvas.addEventListener('mouseup', mouseUp, false);
  canvas.addEventListener('dblclick', doubleClick, false);


  // GUI

  gui = new dat.GUI();
  gui.add(control, 'particleNum', 0, 500).step(1).name('Particle Num').onChange(function () {
    var n = (control.particleNum | 0) - particles.length;
    if (n > 0)
    addParticle(n);else
    if (n < 0)
    removeParticle(-n);
  });
  gui.add(GravityPoint, 'interferenceToPoint').name('Interference Between Point');
  gui.close();


  // Start Update

  var loop = function () {
    var i, len, g, p;

    context.save();
    context.fillStyle = BACKGROUND_COLOR;
    context.fillRect(0, 0, screenWidth, screenHeight);
    context.fillStyle = grad;
    context.fillRect(0, 0, screenWidth, screenHeight);
    context.restore();

    for (i = 0, len = gravities.length; i < len; i++) {
      g = gravities[i];
      if (g.dragging) g.drag(mouse);
      g.render(context);
      if (g.destroyed) {
        gravities.splice(i, 1);
        len--;
        i--;
      }
    }

    bufferCtx.save();
    bufferCtx.globalCompositeOperation = 'destination-out';
    bufferCtx.globalAlpha = 0.35;
    bufferCtx.fillRect(0, 0, screenWidth, screenHeight);
    bufferCtx.restore();

    // パーティクルをバッファに描画
    // for (i = 0, len = particles.length; i < len; i++) {
    //     particles[i].render(bufferCtx);
    // }
    len = particles.length;
    bufferCtx.save();
    bufferCtx.fillStyle = bufferCtx.strokeStyle = '#fff';
    bufferCtx.lineCap = bufferCtx.lineJoin = 'round';
    bufferCtx.lineWidth = PARTICLE_RADIUS * 2;
    bufferCtx.beginPath();
    for (i = 0; i < len; i++) {
      p = particles[i];
      p.update();
      bufferCtx.moveTo(p.x, p.y);
      bufferCtx.lineTo(p._latest.x, p._latest.y);
    }
    bufferCtx.stroke();
    bufferCtx.beginPath();
    for (i = 0; i < len; i++) {
      p = particles[i];
      bufferCtx.moveTo(p.x, p.y);
      bufferCtx.arc(p.x, p.y, p.radius, 0, Math.PI * 2, false);
    }
    bufferCtx.fill();
    bufferCtx.restore();

    // バッファをキャンバスに描画
    context.drawImage(bufferCvs, 0, 0);

    requestAnimationFrame(loop);
  };
  loop();

})();
//# sourceURL=pen.js
    </script><div class="dg ac">
    	<div class="header">
  		<h1>This Website code is made by <a href = "https://www.howtokr.com"> HowtoKR.com</a></h1>
  		<h2>CLick to Add Gravity Points with Masses</h2>
		</div>
    	

  
  




 
</body></html>
